#tag ClassClass LineHighlighterInherits Thread	#tag Event		Sub Run()		  dim owner as CustomEditField = self.owner		  if owner = nil then Return		  		  dim lowestChange as Integer = owner.LineCount		  dim highestChange as Integer = -1		  		  dim wasUndo as Boolean = owner.IsUndoing		  		  //do some heavy processing here!! :P		  //reprocess all changed lines...		  while changedLines.RangeCount > 0		    		    dim currentRange as ModifiedLineRange = changedLines.NextRange		    dim highlightedLinesInRange as new Dictionary		    dim index as Integer		    dim highlightingScreenLines as Boolean = False		    		    while currentRange.NextIndex		      // get a new lock for each iteration so that we do not block access to the lines in main thread for too long		      dim lock as new LinesLock(owner)		      		      if owner.IsUndoing then		        wasUndo = true		      end if		      		      while owner.VisibleLineRange.NextIndex		        index = owner.VisibleLineRange.CurrentIndex		        HighlightLine(index, highlightedLinesInRange)		        highlightingScreenLines = true		      wend		      		      if highlightingScreenLines then		        highlightingScreenLines = False		        DoneWithScreenLines		      end if		      		      index = currentRange.CurrentIndex		      HighlightLine(index, highlightedLinesInRange)		      		      // remember the range of changed lines		      if index < lowestChange then lowestChange = index		      if index > highestChange then highestChange = index		    wend		    		  wend		  		  HighlightingDone		  		  if owner.KeepEntireTextIndented and lowestChange <= highestChange then		    if not wasUndo or owner.IndentVisually then		      if not owner.IndentVisually then		        dim caretLine as Integer = owner.CaretLine		        if lowestChange <= caretLine then		          //		          // Here we have a complicated problem: since the user can edit the indentation whitespace,		          // he could try to delete them because he wants to backspace an indented line so far that it merges		          // with the previous line (i.e. delete the tab chars and then delete the line delimiter).		          // To allow that, we must not re-indent the line he's editing, or we'd restore the indenting		          // while he's trying to delete it.		          //		          // The current solution is to check if the cursor is at the start of the line - if it is, then		          // we do not re-indent the line.		          //		          dim caretCol as Integer = owner.CaretColumn		          dim lineText as String = owner.GetLine(caretLine)		          dim textLeftOfCaret as String = lineText.Left(caretCol)		          if textLeftOfCaret.Trim = "" then		            // Cursor is at start of line or inside indentation space		            lowestChange = caretLine + 1		          end		        end if		      end		      StartReindenting lowestChange, highestChange		    end if		  end if		End Sub	#tag EndEvent	#tag Method, Flags = &h0		Sub Constructor(owner as customEditField, definition as highlightdefinition, changedLines as modifiedLineRangeManager, buffer as gapBuffer, lines as linemanager)		  self.definition = definition		  self.changedLines = changedLines		  self.buffer = buffer		  self.mLines = new WeakRef(lines)		  self.mOwner = new WeakRef(owner)		  		  self.Priority = Thread.NormalPriority		  Run		  		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub DoneWithScreenLines()		  if not MessageCenter.isMessageInQueue (self, 1, ScreenLinesHighlightedMsg) then		    dim msg as new Message(self, self)		    msg.addInfo(1, ScreenLinesHighlightedMsg)		    MessageCenter.sendMessage(msg)		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub HighlightingDone()		  if not MessageCenter.isMessageInQueue (self, 1, HighlightDoneMsg) then		    dim msg as new Message(self, self)		    msg.addInfo(1, HighlightDoneMsg)		    MessageCenter.queueMessage(msg)		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub HighlightLine(index as integer, highlightedLinesInRange as Dictionary = nil)		  dim line, previous, nextLine as TextLine		  dim context, previousContext as HighlightContext		  dim processed as Integer		  		  dim lineFoldingsEnabled as Boolean = owner.EnableLineFoldings		  		  dim lines as LineManager = LineManager(mLines.Value)		  		  //get line		  line = lines.getLine(index)		  if line = nil then return //line can be nil if no longer in document		  if highlightedLinesInRange <> nil and highlightedLinesInRange.HasKey(index) then Return		  		  //get context of previous line		  dim previousState as String		  previous = lines.getLine(index - 1)		  if previous <> nil then		    Context = previous.Context		    previousState = previous.IndentationStateOut		  end if		  		  previousContext = line.Context		  context = line.Highlight(definition, previousState, buffer, context)		  if highlightedLinesInRange <> nil then highlightedLinesInRange.Value(index) = nil		  		  //restore fold markers		  //if the line is a blockStart, or if it was and it's folded, check the fold markers		  if lineFoldingsEnabled and (line.isBlockStart or (line.folded and not line.isBlockStart)) then		    nextLine = lines.getLine(lines.nextBlockEndLine(index, true))		    if nextLine <> nil and ((line.folded <> not nextLine.visible) or (line.folded and not line.isBlockStart)) then		      //if we got to this point, is because it's a startblock in an invalid state.		      line.isBlockStart = true		      call lines.toggleLineFolding(index)		    end if		  end if		  		  LineHighlighted(index)		  processed = processed + 1		  		  if context <> nil then		    //scan next		    do		      index = index + 1		      line = lines.getLine(index)		      if line = nil then exit do		      if line.Context = context then Continue		      context = line.Highlight(definition, previousState, buffer, context)		      processed = processed + 1		      LineHighlighted(index)		      if highlightedLinesInRange <> nil then highlightedLinesInRange.Value(index) = nil		    Loop Until context = nil		    		    //add final line		    line = lines.getLine(index + 1)		    if line <> nil then		      owner.InvalidateLine(index + 1)		      call changedLines.AddRange(new ModifiedLineRange(index + 1, 1))//it will be highlighted in a future pass		    end if		    		    //if context changed		  elseif previousContext <> Context then		    		    index = index + 1		    line = lines.getLine(index)		    while line <> nil and line.Context = previousContext		      if highlightedLinesInRange <> nil then highlightedLinesInRange.Value(index) = nil		      context = line.Highlight(definition, previousState, buffer, context)		      processed = processed + 1		      LineHighlighted(index)		      index = index + 1		      line = lines.getLine(index)		    wend		    		    //final line		    if line <> nil then		      call changedLines.AddRange(new ModifiedLineRange(index, 1))		      owner.InvalidateLine(index)		    end if		    		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub LineHighlighted(index as integer)		  dim msg as new Message(self, self)		  msg.addInfo(1, LineHighlightedMsg)		  msg.addInfo(2, index)		  MessageCenter.sendMessage(msg)		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Sub StartReindenting(startLine as Integer, endLine as Integer)		  if not MessageCenter.isMessageInQueue (self, 1, StartReindenting) then		    dim msg as new Message(self, self)		    msg.addInfo(1, StartReindenting)		    msg.addInfo(2, startLine)		    msg.addInfo(3, endLine)		    MessageCenter.queueMessage(msg)		  end if		End Sub	#tag EndMethod	#tag Property, Flags = &h1		Protected buffer As gapBuffer	#tag EndProperty	#tag Property, Flags = &h1		Protected changedLines As ModifiedLineRangeManager	#tag EndProperty	#tag Property, Flags = &h0		definition As highlightdefinition	#tag EndProperty	#tag Property, Flags = &h1		#tag Note			LineManager		#tag EndNote		Protected mLines As WeakRef	#tag EndProperty	#tag Property, Flags = &h21		Private mOwner As weakRef	#tag EndProperty	#tag ComputedProperty, Flags = &h21		#tag Getter			Get			  if mOwner <> nil then			    return CustomEditField(mOwner.Value)			  else			    //stop thread, since the owner is no longer valid			    self.Kill			    return nil			  end if			End Get		#tag EndGetter		Private owner As CustomEditField	#tag EndComputedProperty	#tag Constant, Name = HighlightDoneMsg, Type = Double, Dynamic = False, Default = \"0", Scope = Public	#tag EndConstant	#tag Constant, Name = LineHighlightedMsg, Type = Double, Dynamic = False, Default = \"1", Scope = Public	#tag EndConstant	#tag Constant, Name = ScreenLinesHighlightedMsg, Type = Double, Dynamic = False, Default = \"2", Scope = Public	#tag EndConstant	#tag Constant, Name = StartReindenting, Type = Double, Dynamic = False, Default = \"3", Scope = Public	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Priority"			Visible=true			Group="Behavior"			InitialValue="5"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="StackSize"			Visible=true			Group="Behavior"			InitialValue="0"			Type="Integer"			InheritedFrom="Thread"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass